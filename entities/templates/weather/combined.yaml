---
# trigger based template weather entity which combines all forecasts
triggers:
  - alias: "Update combined weather forecast every 5 minutes at 30 seconds past the minute"
    trigger: time_pattern
    minutes: "/5"
    seconds: "30"
  - alias: "Update combined weather forecast on Home Assistant startup"
    trigger: homeassistant
    event: start
  - alias: "Update combined weather forecast on manual trigger event"
    trigger: event
    event_type: update_combined_forecast
actions:
  - alias: "Define weights for different weather integrations"
    variables:
      # set to true to get an persistent notification every time the weather is updated
      # the notification will contain information on the forecast list, and the entities used
      debug: false
      # change this to your own entity_id's and preferences (or remove the variable)
      weight:
        - entity_id: weather.knmi
          current: 3
          daily: 3
          hourly: 4
        - entity_id: weather.buienradar
          current: 2
          daily: 2
      forecast_all:
        - attr: condition
        - attr: wind_bearing
          round: 2
        - attr: cloud_coverage
          round: 0
        - attr: temperature
          round: 1
        - attr: wind_speed
          round: 2
        - attr: precipitation
          round: 2
        - attr: precipitation_probability
          round: 0
        - attr: dew_point
          round: 1
        - attr: uv_index
          round: 2
        - attr: apparent_temperature
          round: 1
        - attr: pressure
          round: 2
        - attr: humidity
          round: 0
      forecast_daily:
        - attr: templow
          round: 2
        - attr: wind_gust_speed
          round: 0
      forecast_twice_daily:
        - attr: is_daytime
  - alias: Set right forecast type
    variables:
      type: hourly
      supported: [2, 3, 6, 7]
  - alias: Get the forecast data from the entities
    sequence: &get_forecasts
      - alias: Get all entities which support the forecast type
        variables:
          weather_entities: >
            {{
              states.weather
                | selectattr('attributes.supported_features', 'defined')
                | selectattr('attributes.supported_features', 'in', supported)
                | map(attribute='entity_id')
                | reject('in', integration_entities('template'))
                | select('has_value')
                | list
            }}
      - alias: Get forecasts in case there are entities
        if: "{{ weather_entities | count > 0 }}"
        then:
          - alias: "Set forecast available flag when entities found"
            variables:
              forecast_available: true
          - alias: Get hourly forecast data out of selected entities
            action: weather.get_forecasts
            data:
              type: "{{ type }}"
            target:
              entity_id: "{{ weather_entities }}"
            response_variable: forecast
        else:
          - alias: "Set forecast unavailable flag when no entities found"
            variables:
              forecast_available: false
  - alias: Combine the forecasts in one
    variables:
      hourly_entities: "{{ weather_entities }}"
      hourly: &combine_forecasts >
        {# set number of days to use for forecasts #}
          {% set forecast_days = 3 if type == 'hourly' else 10 %}
        {# define valid forecast attributes and precision for rounding #}
          {% set forecast_attr = forecast_all if type == 'hourly' else forecast_all + forecast_daily if type == 'daily' else forecast_all + forecast_twice_daily %}
        {# check if forecast is retreived #}
          {% if forecast_available %}
          {# combine all forecasts in one list #}
            {% if weight is defined
                and weight is list
                and weight | count > 0
                and weight[0] is mapping
            %}
              {% set ns = namespace(all=[]) %}
              {% for k, v in forecast.items() %}
                {% set w = weight
                            | selectattr('entity_id', 'eq', k)
                            | map(attribute=type)
                            | first
                            | default(1) %}
                {% set ns.all = ns.all + v.forecast * w %}
              {% endfor %}
              {% set all = ns.all %}
            {% else %}
              {% set all = forecast.values() | map(attribute='forecast') | sum(start=[]) %}
            {% endif %}
          {# make sure no old forecasts are included, and only 3 days for hourly forecasts, and 10 days for daily #}
            {% set compare_start = today_at() if type == 'daily' else now() - timedelta(hours=1) %}
            {% set compare_end = now() + timedelta(days=forecast_days) %}
          {# align datetimes so they all use local timezone, and the same start time for daily forecasts #}
            {% set ns = namespace(aligned=[], forecast=[]) %}
            {% for item in all if compare_start <= as_datetime(item.datetime) | as_local <= compare_end %}
              {% set new_dt = item.datetime | as_datetime(item.datetime) | as_local %}
              {% set new_dt = new_dt.isoformat() if type in ['hourly', 'twice_daily'] else new_dt.replace(hour=0, minute=0).isoformat() %}
              {% set ns.aligned = ns.aligned + [dict(item, datetime=new_dt)] %}
            {% endfor %}
          {# set list of unique datetime #}
            {% set dt_list = ns.aligned | map(attribute='datetime') | unique | sort | list %}
          {# create forecast list item for each datetime #}
            {% for dt in dt_list %}
              {% set forecasts = ns.aligned | selectattr('datetime', 'eq', dt) | list %}
              {% set dt_ns = namespace(keys=[], forecast=dict(datetime=dt)) %}
              {# find forecast available forecast items #}
                {% for item in forecasts %}
                  {% set dt_ns.keys = dt_ns.keys + item.keys() | list %}
                {% endfor %}
                {# remove unsupported types for template weather #}
                {% set allowed_keys = forecast_attr | map(attribute='attr') | list %}
                {% set keys_list = dt_ns.keys | unique | select('in', allowed_keys) %}
              {# find value for each forecast item #}
                {% for key in keys_list %}
                  {% set key_items = forecasts | selectattr(key, 'defined') | map(attribute=key) | list %}
                  {# find most frequent item for condition #}
                    {% if key == 'condition' %}
                      {% if 'clear-night' in key_items %}
                        {% set key_items = key_items | map('replace', 'sunny', 'clear-night') | list %}
                      {% endif %}
                      {% set add_dict = dict(condition=statistical_mode(key_items, none)) %}
                      {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %}
                    {% elif key == 'is_daytime' %}
                      {% set add_dict = dict(is_daytime=key_items[0]) %}
                      {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %}
                  {# find median for other (numeric) forecast types #}
                    {% else %}
                      {# filter out non numeric values #}
                        {% set values = key_items  | map('replace', none, 0) | select('is_number') | map('float') | list | sort %}
                        {% if values | count > 0 %}
                          {# add forecast item to forecast #}
                            {% set round = forecast_attr | selectattr('attr', 'eq', key) | map(attribute='round') | list | first %}
                            {% set add_dict = {key: median(values)|round(round)} %}
                            {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %}
                        {% endif %}
                    {% endif %}
                {% endfor %}
              {# combine forecast for each datetime in one list #}
                {% set ns.forecast = ns.forecast + [dt_ns.forecast] %}
            {% endfor %}
          {# output the forecast #}
            {{ ns.forecast }}
        {# create twice daily forecast based on hourly forecast if not provided normally #}
        {% elif type == 'twice_daily' and hourly | count > 0 %}
          {% set times = hourly | selectattr('datetime', 'search', 'T09:00|T18:00') | map(attribute='datetime') | list %}
          {% set ns = namespace(forecast=[], item={}) %}
          {% for t in times %}
            {% set day = t is search 'T09:00' %}
            {% set dates = hourly | map(attribute='datetime') | list %}
            {% set index = dates.index(t) %}
            {% set data = hourly[index:index+(9 if day else 13)] %}
            {% set key_list = data[0].keys() | list %}
            {% set ns.item = {'datetime': t, 'is_daytime': day} %}
            {% for key in key_list %}
              {% set key_items = data | selectattr(key, 'defined') | map(attribute=key) | list %}
              {% if key_items[0] is string %}
                {% set ns.item = dict(ns.item, **{key: key_items | statistical_mode}) %}
              {% elif key == 'temperature' %}
                {% set ns.item = dict(ns.item, **{key: key_items | max, 'templow': key_items | min}) %}
              {% elif key_items[0] | is_number %}
                {% set r = forecast_attr | selectattr('attr', 'eq', key) | map(attribute='round') | first | default(1) %}
                {% set ns.item = dict(ns.item, **{key: key_items | average | round(r)}) %}
              {% endif %}
            {% endfor %}
            {% set ns.forecast = ns.forecast + [ns.item] %}
          {% endfor %}
          {{ ns.forecast }}
        {% else %}
          []
        {% endif %}
  - alias: Set right forecast type
    variables:
      type: daily
      supported: [1, 3, 5, 7]
  - alias: Get the forecast data from the entities
    sequence: *get_forecasts
  - alias: Combine the forecasts in one
    variables:
      daily_entities: "{{ weather_entities }}"
      daily: *combine_forecasts
  - alias: Set right forecast type
    variables:
      type: twice_daily
      supported: [4, 5, 6, 7]
  - alias: Get the forecast data from the entities
    sequence: *get_forecasts
  - alias: Combine the forecasts in one
    variables:
      twice_daily_entities: "{{ weather_entities }}"
      twice_daily: *combine_forecasts
  - alias: Set variable for weather entities for attributes
    variables:
      weather_entities: >
        {{
          states.weather
            | map(attribute='entity_id')
            | reject('in', integration_entities('template'))
            | select('has_value')
            | list
        }}
      current_values: >
        {% set attr_all = forecast_all + forecast_daily %}
        {% set ns = namespace(attributes=['condition'], values={}) %}
        {% for e in weather_entities %}
          {% set ns.attributes = ns.attributes + states[e].attributes.items() | selectattr('1', 'is_number') | map(attribute='0') | reject('eq', 'supported_features') | list %}
        {% endfor %}
        {% set attributes = ns.attributes | unique | list %}
        {% for a in attributes %}
          {% if weight is defined and weight is list and weight[0] is mapping %}
            {% set ns.weight = [] %}
            {% for e in weather_entities %}
              {% set w = weight | selectattr('entity_id', 'eq', e) | map(attribute='current') | first | default(1) %}
              {% set ns.weight = ns.weight + [states(e) if a == 'condition' else state_attr(e, a)] * w %}
            {% endfor %}
            {% set values = ns.weight | reject('none') | list %}
          {% else %}
            {% if a == 'condition' %}
              {% set values = weather_entities | map('states') | list %}
            {% else %}
              {% set values = weather_entities | map('state_attr', a) | select('is_number') | list %}
            {% endif %}
          {% endif %}
          {% set r = attr_all | selectattr('attr', 'eq', a) | map(attribute='round') | first | default(1) %}
          {% set value = values | statistical_mode if a == 'condition' else values | median(none) | round(r, default=none) %}
          {% set ns.values = dict(ns.values, **{a: value}) %}
        {% endfor %}
        {{ ns.values }}
  - alias: "Send debug notification if debug mode is enabled"
    if: "{{ debug | default(false) | bool(false) }}"
    then:
      - alias: Send notification with some debug date
        action: persistent_notification.create
        data:
          title: Weather Combined debug
          message: |
            hourly: {{ hourly | count }} items
            hourly_entities: "{{ hourly_entities | join(', ') }}"
            daily: {{ daily | count }} items
            daily_entities: {{ daily_entities | join(', ') }}
            twice_daily: {{ twice_daily | count }} items
            twice_daily_entities: {{ twice_daily_entities | join(', ') }}
            current_values: {{ current_values }}
# template weather entity which will combine all the data from the other weather entities
weather:
  - name: Combined
    unique_id: 97b3c060-3146-41dd-91d9-0765d2e15e16
    condition_template: "{{ current_values.get('condition', none) }}"
    temperature_template: "{{ current_values.get('temperature', none) }}"
    apparent_temperature_template: "{{ current_values.get('apparent_temperature', none) }}"
    pressure_template: "{{ current_values.get('pressure', none) }}"
    wind_speed_template: "{{ current_values.get('wind_speed', none) }}"
    wind_gust_speed_template: "{{ current_values.get('wind_gust_speed', none) }}"
    visibility_template: "{{ current_values.get('visibility', none) }}"
    humidity_template: "{{ current_values.get('humidity', none) }}"
    wind_bearing_template: "{{ current_values.get('wind_bearing', none) }}"
    ozone_template: "{{ current_values.get('ozone', none) }}"
    cloud_coverage_template: "{{ current_values.get('cloud_coverage', none) }}"
    dew_point_template: "{{ current_values.get('dew_point', none) }}"
    temperature_unit: &temp_unit "Â°C"
    pressure_unit: "hPa"
    wind_speed_unit: "km/h"
    visibility_unit: "km"
    precipitation_unit: "mm"
    forecast_hourly_template: "{{ hourly }}"
    forecast_daily_template: "{{ daily }}"
    forecast_twice_daily_template: "{{ twice_daily | default([], true) }}"
# other template sensors using the combined forecast data generated for the weather entity
sensor:
  - unique_id: 7b190917-6d93-4c01-8854-4a1b7bf9d886
    name: Weather Combined Max Temp Today
    state: >
      {{
        daily
          | selectattr('datetime', 'search', now().date()| string)
          | map(attribute='temperature')
          | list
          | first
      }}
    <<: &temp_sensor_config
      device_class: temperature
      state_class: measurement
      unit_of_measurement: *temp_unit
      availability: >
        {{
          daily is defined
          and daily is list
          and daily | selectattr('datetime', 'search', now().date() | string) | list | count > 0
        }}
  - unique_id: e61acc80-7348-45ed-b83c-070109cd4fe1
    name: Weather Combined Max Temp Tomorrow
    state: >
      {{
        daily
          | selectattr('datetime', 'search', (now() + timedelta(days=1)).date()
          | string)
          | map(attribute='temperature')
          | list
          | first
      }}
    <<: *temp_sensor_config
  - unique_id: 3098ef4f-aa24-4c27-ae00-514b699a1bfa
    name: Weather Combined daily condition
    state: "{{ daily[0].condition }}"
    icon: >
      {% set icon = {
          "clear-night": "mdi:weather-night",
          "cloudy": "mdi:weather-cloudy",
          "exceptional": "mdi:alert-circle-outline",
          "fog": "mdi:weather-fog",
          "hail": "mdi:weather-hail",
          "lightning": "mdi:weather-lightning",
          "lightning-rainy": "mdi:weather-lightning-rainy",
          "pouring": "mdi:weather-pouring",
          "rainy": "mdi:weather-rainy",
          "snowy": "mdi:weather-snowy",
          "snowy-rainy": "mdi:weather-snowy-rainy",
          "sunny": "mdi:weather-sunny",
          "windy": "mdi:weather-windy",
          "windy-variant": "mdi:weather-windy-variant",
          "partlycloudy": "mdi:weather-partly-cloudy"
        }
      %}
      {{ icon.get(daily[0].condition, 'mdi:cloud-alert') }}
    availability: "{{ daily is defined and daily is list and daily | count > 0 }}"
binary_sensor:
  - unique_id: 5e88168e-bd66-4f98-8a12-e4cab0fb42c8
    name: Weather combined sun in next hours
    state: >
      {% set next_hours = hourly[:3] | map(attribute='condition') | list %}
      {{ next_hours | select('in', ['partlycloudy', 'sunny']) | list | count > 0 }}
    icon: >
      {% set icon = {
          "clear-night": "mdi:weather-night",
          "cloudy": "mdi:weather-cloudy",
          "exceptional": "mdi:alert-circle-outline",
          "fog": "mdi:weather-fog",
          "hail": "mdi:weather-hail",
          "lightning": "mdi:weather-lightning",
          "lightning-rainy": "mdi:weather-lightning-rainy",
          "pouring": "mdi:weather-pouring",
          "rainy": "mdi:weather-rainy",
          "snowy": "mdi:weather-snowy",
          "snowy-rainy": "mdi:weather-snowy-rainy",
          "sunny": "mdi:weather-sunny",
          "windy": "mdi:weather-windy",
          "windy-variant": "mdi:weather-windy-variant",
          "partlycloudy": "mdi:weather-partly-cloudy"
        }
      %}
      {% set next_hours = hourly[:3] | map(attribute='condition') | list %}
      {{ icon.get(statistical_mode(next_hours), 'mdi:cloud-alert') }}
    availability: "{{ hourly is defined and hourly is list and hourly | count >= 3 }}"
