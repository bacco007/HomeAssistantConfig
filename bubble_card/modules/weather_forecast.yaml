weather_forecast:
  name: Bubble Weather
  version: v1.1.0
  creator: Clooos
  supported:
    - button
  description: |
    Full weather card with weather-based animations and daily or hourly forecasts.
    <br><br>
    Create a new Button card, set the button type to "State", choose any "weather" entity, and the module takes care of the rest.
    <br><br>
    <img src="https://raw.githubusercontent.com/Clooos/Bubble-Card/refs/heads/main/img/bubble-weather-module.gif" />
    <br><br>
    <code-block><pre>
    weather_forecast:
        type: daily
        max_days: 5
        disable_dynamic_background: false
        disable_animations: false
    </pre></code-block>
  code: |-
    .bubble-container::before {
      display: none;
    }

    .bubble-main-icon-container.bc-wx-hide-icon-bg {
      background: transparent !important;
    }

    .bubble-container.bc-weather-card {
      overflow: hidden;
      scrollbar-gutter: stable both-edges;
      isolation: isolate;
      contain: layout style paint;
    }

    .bubble-container.bc-weather-card:not(.bc-wx-background-only) {
      min-height: 180px;
    }

    .bc-weather-card:not(.bc-wx-background-only) .bubble-sub-button-container {
      align-self: flex-start !important;
    }

    .bc-weather-card:not(.bc-wx-background-only) .bubble-sub-button-bottom-container {
      bottom: 140px !important;
    }

    .bc-weather-card:not(.bc-wx-background-only).bc-wx-hidden .bubble-sub-button-bottom-container {
      bottom: unset !important;
    }

    .bc-weather-card.bc-wx-background-only .bubble-sub-button-container {
      margin-top: 0 !important;
    }

    .bc-weather-card.bc-wx-background-only.bc-wx-has-bottom-sub-buttons .bubble-sub-button-container {
      margin-top: 10px !important;
    }

    .bc-weather-card.bc-wx-background-only-minimal .bubble-sub-button-container {
      display: none !important;
    }

    .bc-weather-card.bc-wx-background-only-minimal .bubble-sub-button-bottom-container {
      position: static !important;
      top: auto !important;
      bottom: auto !important;
      width: calc(100% - 16px) !important;
      margin: 0 8px 0 8px !important;
      pointer-events: auto !important;
    }

    .bc-weather-card.bc-wx-weather-only .bubble-sub-button-container,
    .bc-weather-card.bc-wx-weather-only .bubble-sub-button-bottom-container {
      display: none !important;
    }

    .bubble-container.bc-weather-card.bc-square-card {
      aspect-ratio: 1 / 1 !important;
      height: 100% !important;
    }

    .bc-weather-card .bubble-wrapper {
      inset: 0;
      width: 100%;
    }

    .bc-weather-card .bubble-background {
      inset: 0;
      width: 100%;
    }

    .bc-weather-card .bubble-wrapper.fixed-top {
      align-items: center;
    }

    .fixed-top .bubble-sub-button-container {
      margin-top: 10px;
    }

    .bubble-wrapper.fixed-top .bubble-content-container {
      display: flex;
      align-items: center;
      align-self: flex-start;
      overflow: hidden;
      flex-grow: 1;
      margin-top: 1px;
    }
    .bc-wx-p-wrap {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      contain: strict;
      transform: translateZ(0);
    }

    .bc-wx-p-wrap .row {
      position: absolute;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }

    .bc-wx-p-wrap .row.back {
      z-index: 1;
      opacity: 0.85;
      filter: blur(.2px);
    }

    .bc-wx-p-wrap.bc-stars .row {
      z-index: 0;
    }

    .bc-wx-p {
      position: absolute;
      pointer-events: none;
      will-change: transform;
      animation-fill-mode: both;
      --d: 1s;
      --dl: 0s;
    }

    .bc-wx-p.rain {
      bottom: 100%;
      width: 15px;
      height: 120px;
      animation: bc-wx-drop var(--d) linear infinite;
      animation-delay: var(--dl);
      --rain-r: 255;
      --rain-g: 255;
      --rain-b: 255;
      --rain-a: .28;
      --rain-w: 1.2px;
      --rain-h: 80%;
    }

    .bc-wx-p.rain::after {
      content: "";
      position: absolute;
      left: 7px;
      top: 0;
      width: var(--rain-w, 1.2px);
      height: var(--rain-h, 80%);
      background:
        linear-gradient(
          to bottom,
          rgba(var(--rain-r),var(--rain-g),var(--rain-b),0),
          rgba(var(--rain-r),var(--rain-g),var(--rain-b),var(--rain-a))
        );
      animation: bc-wx-stem var(--d) linear infinite;
      animation-delay: var(--dl);
    }

    @keyframes bc-wx-drop {
      0% { transform: translate3d(0, -120px, 0); }
      100% { transform: translate3d(0, 110vh, 0); }
    }

    @keyframes bc-wx-stem {
      0%, 90% { opacity: 1; }
      100% { opacity: 0; }
    }

    .bc-wx-p.snow {
      top: -16px;
      border-radius: 50%;
      background:
        radial-gradient(
          circle,
          rgba(255,255,255,1) 0 52%,
          rgba(255,255,255,.96) 65%,
          rgba(255,255,255,0) 80%
        );
      box-shadow:
        0 0 0 1px rgba(255,255,255,.9),
        0 1px 2px rgba(0,0,0,.06);
      animation: bc-wx-snow var(--d) linear infinite;
      animation-delay: var(--dl);
    }

    @keyframes bc-wx-snow {
      0% { transform: translate3d(0, -16px, 0); }
      50% { transform: translate3d(var(--drift, 18px), 50vh, 0); }
      100% { transform: translate3d(0, 110vh, 0); }
    }

    .bc-wx-p.hail {
      top: -20px;
      border-radius: 50%;
      background: rgba(255,255,255,1);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.85),
        0 1px 1px rgba(0,0,0,.08);
      animation: bc-wx-hail var(--d) linear infinite;
      animation-delay: var(--dl);
    }

    @keyframes bc-wx-hail {
      0% { transform: translate3d(0, -20px, 0); }
      100% { transform: translate3d(var(--drift, 4px), 110vh, 0); }
    }

    .bc-wx-p.star {
      border-radius: 50%;
      background: rgba(255,255,255,.95);
      animation: bc-wx-twinkle var(--d) ease-in-out infinite;
      animation-delay: var(--dl);
    }

    @keyframes bc-wx-twinkle {
      0%, 100% { opacity: .15; }
      50% { opacity: 1; }
    }

    .bc-wx-cloud-canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    .bc-wx-flash {
      position: absolute;
      inset: 0;
      background: #fff;
      opacity: 0;
      animation: bc-wx-flash 5.2s linear infinite;
      contain: strict;
      transform: translateZ(0);
    }

    @keyframes bc-wx-flash {
      0%, 92%, 100% { opacity: 0; }
      93% { opacity: .25; }
      94% { opacity: 0; }
      96% { opacity: .45; }
      97% { opacity: 0; }
    }

    .bc-weather {
      position: absolute;
      box-sizing: border-box;
      padding: 16px;
      bottom: 8px;
      left: 0;
      right: 0;
      width: 100%;
      pointer-events: none;
      contain: layout style;
    }

    .bc-weather.bc-wx-top {
      top: 8px;
      bottom: auto;
    }

    .bc-weather-grid {
      display: grid;
      gap: 8px;
      align-items: end;
      width: 100%;
    }

    .bc-weather-day {
      display: grid;
      grid-template-rows: auto 28px auto;
      justify-items: center;
      text-align: center;
      gap: 8px;
    }

    .bc-weather-day .day-label {
      font-size: 12px;
      opacity: .9;
    }

    .bc-weather-day ha-icon {
      width: 26px;
      height: 26px;
      --mdc-icon-size: 26px;
    }

    .bc-weather-day .temps {
      display: grid;
      grid-auto-flow: row;
      gap: 2px;
      align-items: center;
      justify-items: center;
      font-size: 12px;
      line-height: 1.05;
    }

    .bc-weather-day .hi {
      font-weight: 600;
    }

    .bc-weather-day .lo {
      opacity: .85;
    }

    ${(() => {
      const cfg = this.config.weather_forecast || {};
      const type = cfg.type || 'daily';
      const max = Number.isFinite(cfg.max_days) ? cfg.max_days : 7;
      const minW = Number.isFinite(cfg.min_day_width) ? cfg.min_day_width : 50;
      const ttlDefaults = { hourly: 15, twice_daily: 180, daily: 60 };
      const ttlMin = ttlDefaults[type] ?? 60;
      const moduleMem = window.__bcWF = window.__bcWF || {};
      const stateMem = moduleMem.state || (moduleMem.state = {});
      const cacheMem = moduleMem.cache || (moduleMem.cache = {});
      const requestMem = moduleMem.requests || (moduleMem.requests = {});
      const hostStateMap =
        moduleMem.hostStateMap || (moduleMem.hostStateMap = new WeakMap());
      const cloudLayerMem =
        moduleMem.cloudLayers || (moduleMem.cloudLayers = new WeakMap());
      const getHostState = target => {
        if (!target) return null;
        let record = hostStateMap.get(target);
        if (!record) {
          record = {};
          hostStateMap.set(target, record);
        }
        return record;
      };
      const pruneMemStore = (store, cap = 10) => {
        if (!store) return;
        const entries = Object.entries(store);
        if (entries.length <= cap) return;
        entries
          .sort((a, b) => ((a[1]?.ts ?? 0) - (b[1]?.ts ?? 0)))
          .slice(0, Math.max(0, entries.length - cap))
          .forEach(([key]) => { delete store[key]; });
      };
      const prefersReducedMotion =
        window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches || false;
      const animOn = !cfg.disable_animations && !prefersReducedMotion;
      const bgOn = !cfg.disable_dynamic_background;
      const hideIconBg = cfg.hide_icon_background ?? false;
      const cardLayout = cfg.card_layout || 'default';
      const isWeatherOnlyMode = cardLayout === 'weather_only' || cardLayout === 'weather_only_bg';
      const isWeatherOnlyMinimal = cardLayout === 'weather_only';
      const isBackgroundOnly = cardLayout === 'background_only';
      const isBackgroundOnlyMinimal = cardLayout === 'background_only_minimal';
      const isWeatherHidden = isBackgroundOnly || isBackgroundOnlyMinimal;
      const hideHeaderContent = isWeatherOnlyMode || isBackgroundOnlyMinimal;

      const ha = (typeof hass !== 'undefined' && hass) ? hass : this?.hass;
      if (!ha) return;
      const entityId = typeof entity === 'string' ? entity : (this?.entity?.entity_id || '');
      if (!entityId || !entityId.startsWith('weather.')) return;

      // Performance Optimization: Cache check
      const host = this?.elements?.cardWrapper || card;
      const hostState = getHostState(host);
      const last = stateMem[entityId];
      const curState = ha.states[entityId];
      const curSun = ha.states['sun.sun'];
      const now = Date.now();
      const renderedRoot = host?.querySelector?.('.bc-weather');
      let root = renderedRoot;
      const entityRev = curState
        ? [
            curState.state,
            curState.last_updated,
            curState.last_changed,
            curState.attributes?.temperature,
            curState.attributes?.humidity,
            curState.attributes?.pressure,
            curState.attributes?.wind_speed,
            curState.attributes?.wind_bearing,
            curState.attributes?.precipitation,
            curState.attributes?.forecast?.[0]?.datetime,
            curState.attributes?.forecast?.[0]?.condition
          ].map(v => v ?? '').join('|')
        : '';
      const sunRev = curSun
        ? [
            curSun.state,
            curSun.last_updated,
            curSun.attributes?.next_rising,
            curSun.attributes?.next_setting,
            curSun.attributes?.elevation
          ].map(v => v ?? '').join('|')
        : '';
      const isStale = !last 
        || last.entity !== entityRev
        || last.sun !== sunRev
        || (now - last.ts > 60000); // Update at least every minute

      const skipFullRedraw = !isStale && !!renderedRoot;
      
      if (curState || curSun) {
        stateMem[entityId] = { entity: entityRev, sun: sunRev, ts: now };
        pruneMemStore(stateMem, 12);
      }
      try {
        host.classList.add('fixed-top');
        const pos = getComputedStyle(host).position;
        if (!pos || pos === 'static') host.style.position = 'relative';
      } catch {}
      const container =
        this?.elements?.cardContainer ||
        host?.closest?.('.bubble-container') ||
        host;
      container?.classList.add('bc-weather-card');
      if (container?.classList) {
        container.classList.toggle('bc-wx-background-only', isBackgroundOnly || isBackgroundOnlyMinimal);
        container.classList.toggle('bc-wx-background-only-minimal', isBackgroundOnlyMinimal);
        container.classList.toggle('bc-wx-weather-only', isWeatherOnlyMode);
        const bottom = container.querySelector?.('.bubble-sub-button-bottom-container');
        const bottomHasButtons = !!(bottom && bottom.childElementCount > 0);
        container.classList.toggle('bc-wx-has-bottom-sub-buttons', bottomHasButtons);
      }
      if (cardLayout === 'square') {
        container?.classList.add('bc-square-card');
      }

      // Set icon background class
      const iconContainer = this?.elements?.iconContainer;
      if (iconContainer) {
        iconContainer.classList.toggle('bc-wx-hide-icon-bg', hideIconBg);
      }

      const cleanupHostResources = () => {
        if (!hostState) return;
        if (hostState.resizeFrame) {
          cancelAnimationFrame(hostState.resizeFrame);
          hostState.resizeFrame = null;
        }
        if (hostState.heightUpdateFrame) {
          cancelAnimationFrame(hostState.heightUpdateFrame);
          hostState.heightUpdateFrame = null;
        }
        if (hostState.resizeObserver) {
          try { hostState.resizeObserver.disconnect(); } catch {}
          hostState.resizeObserver = null;
        }
        if (root?._ro) {
          try { root._ro.disconnect(); } catch {}
          root._ro = null;
        }
        if (root?._heightRo) {
          try { root._heightRo.disconnect(); } catch {}
          root._heightRo = null;
        }
        if (hostState.parentObserver) {
          hostState.parentObserver.disconnect();
          hostState.parentObserver = null;
        }
        hostState.parentNode = null;
        if (hostState.detachTimeout) {
          clearTimeout(hostState.detachTimeout);
          hostState.detachTimeout = null;
        }
      };

      const scheduleDetachPoll = () => {
        if (!hostState || hostState.detachTimeout) return;
        hostState.detachTimeout = setTimeout(() => {
          hostState.detachTimeout = null;
          if (!host?.isConnected) {
            cleanupHostResources();
            return;
          }
          scheduleDetachPoll();
        }, 60000);
      };

      const watchHostParent = () => {
        if (!hostState || !host?.parentNode) return;
        if (hostState.parentObserver && hostState.parentNode === host.parentNode) return;
        if (hostState.parentObserver) {
          hostState.parentObserver.disconnect();
          hostState.parentObserver = null;
        }
        hostState.parentNode = host.parentNode;
        const mo = new MutationObserver(records => {
          if (!host?.isConnected) {
            cleanupHostResources();
            return;
          }
          for (const record of records) {
            for (const removed of record.removedNodes) {
              if (removed === host) {
                cleanupHostResources();
                return;
              }
            }
          }
        });
        mo.observe(host.parentNode, { childList: true });
        hostState.parentObserver = mo;
      };

      watchHostParent();
      scheduleDetachPoll();

      if (!root) {
        root = Object.assign(document.createElement('div'), {
          className: 'bc-weather',
          innerHTML: '<div class="bc-weather-grid"></div>'
        });
        host.appendChild(root);
      }
      const grid = root.querySelector('.bc-weather-grid');
      const hasTopContent = () => {
        if (hideHeaderContent) return false;
        const cfg = this?.config || {};
        const defaultShowState = (cfg.button_type || 'state') === 'state';
        const showIcon = cfg.show_icon ?? true;
        const showName = cfg.show_name ?? true;
        const showState = cfg.show_state ?? defaultShowState;
        const showAttribute = cfg.show_attribute ?? defaultShowState;
        const showLastChanged = cfg.show_last_changed ?? false;
        const showLastUpdated = cfg.show_last_updated ?? false;
        if (!(showIcon || showName || showState || showAttribute || showLastChanged || showLastUpdated)) {
          return false;
        }
        const els = this?.elements || {};
        const isVisible = el => !!el && !el.classList.contains('hidden');
        return (
          (showIcon && isVisible(els.iconContainer)) ||
          (showName && isVisible(els.name)) ||
          ((showState || showAttribute || showLastChanged || showLastUpdated) && isVisible(els.state))
        );
      };

      const getWeatherMinHeight = () => {
        const contentH = root?.scrollHeight || root?.offsetHeight || 0;
        return Math.max(120, contentH + 16);
      };

      const updateWeatherPosition = (immediate = false) => {
        const noTopContent = !hasTopContent();
        const skipMinHeight = isWeatherHidden;
        root.classList.toggle('bc-wx-top', noTopContent && !skipMinHeight);
        
        const applyHeight = () => {
          if (container) {
            if (noTopContent && !skipMinHeight) {
              const height = getWeatherMinHeight();
              container.style.minHeight = `${height}px`;
            } else {
              container.style.minHeight = '';
            }
          }
        };

        if (immediate) {
          // Use single RAF for immediate mode to ensure layout is complete
          requestAnimationFrame(applyHeight);
        } else {
          // Use double RAF for deferred mode to ensure DOM is fully laid out
          requestAnimationFrame(() => {
            requestAnimationFrame(applyHeight);
          });
        }
      };

      const applyWeatherOnly = () => {
        const els = this?.elements || {};
        const toggleDisplay = (el, on) => {
          if (!el) return;
          el.style.display = on ? '' : 'none';
        };

        const layoutKey = [
          cardLayout,
          hideHeaderContent ? 1 : 0,
          isWeatherHidden ? 1 : 0,
          isWeatherOnlyMinimal ? 1 : 0
        ].join('|');
        if (root?._wxLayoutKey === layoutKey) return;
        if (root) root._wxLayoutKey = layoutKey;

        // Hide card content; optionally strip backgrounds for the minimal mode
        const hideContentContainers = isWeatherOnlyMode || isBackgroundOnlyMinimal;
        toggleDisplay(els.contentContainer, !hideContentContainers);
        toggleDisplay(els.buttonsContainer, !hideContentContainers);
        const hideBackground = isWeatherOnlyMinimal;
        toggleDisplay(els.background, !hideBackground);
        toggleDisplay(root, !isWeatherHidden);
        if (container) {
          container.classList.toggle('bc-wx-hidden', isWeatherHidden);
        }
        if (hideHeaderContent) {
          toggleDisplay(els.iconContainer, false);
          toggleDisplay(els.name, false);
          toggleDisplay(els.state, false);
        } else {
          toggleDisplay(els.iconContainer, true);
          toggleDisplay(els.name, true);
          toggleDisplay(els.state, true);
        }
        if (container) {
          container.style.background = hideBackground ? 'transparent' : '';
          container.style.boxShadow = hideBackground ? 'none' : '';
          container.style.border = hideBackground ? 'none' : '';
          container.style.minHeight = isWeatherHidden ? '0' : '';
        }
        if (host) {
          host.style.background = hideBackground ? 'transparent' : '';
        }
      };

      applyWeatherOnly();
      updateWeatherPosition();

      const el = (tag, cls, txt) => {
        const n = document.createElement(tag);
        if (cls) n.className = cls;
        if (txt != null) n.textContent = txt;
        return n;
      };

      const unit = ha?.config?.unit_system?.temperature || '°C';
      const fmt = v =>
        (v == null || Number.isNaN(+v))
          ? ''
          : `${Math.round(+v)}${unit.replace('°',' °')}`.replace('  ',' ');

      const label = iso => {
        try {
          const d = new Date(iso);
          if (type === 'hourly') {
            return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
          }
          const lang = ha?.locale?.language || navigator.language || 'en-US';
          return d.toLocaleDateString(lang, { weekday:'short' });
        } catch { return ''; }
      };

      const isNight = f => {
        if (typeof f?.is_daytime === 'boolean') return !f.is_daytime;

        const ent = ha?.states?.[entityId];
        if (typeof ent?.attributes?.is_daytime === 'boolean') {
          return !ent.attributes.is_daytime;
        }

        const sunState = ha?.states?.['sun.sun']?.state;
        if (sunState === 'below_horizon') return true;
        if (sunState === 'above_horizon') return false;

        try {
          const d = f?.datetime || f?.time || f?.date
            ? new Date(f.datetime || f.time || f.date)
            : new Date();
          const h = d.getHours();
          return h < 6 || h >= 20;
        } catch { return false; }
      };

      let currentList = null;

      const applyBackground = () => {
        const bg = this?.elements?.background;
        if (!bg) return;

        // Custom attributes for animations
        const ent = ha?.states?.[entityId];
        const attrs = ent?.attributes || {};
        const windSpeed = Number(attrs.wind_speed) || 0;
        const windBearing = Number(attrs.wind_bearing);
        const precip = Number(attrs.precipitation);

        try {
          const pos = getComputedStyle(bg).position;
          if (!pos || pos === 'static') bg.style.position = 'absolute';
          bg.style.left = '0';
          bg.style.right = '0';
          bg.style.top = '0';
          bg.style.bottom = '0';
          bg.style.width = '100%';
          bg.style.height = '100%';
        } catch {}

        const hideCloudLayer = () => {
          const layer = cloudLayerMem.get(bg);
          if (!layer?.canvas) return;
          if (layer.animId) {
            cancelAnimationFrame(layer.animId);
            layer.animId = null;
          }
          if (layer.observer) {
            layer.observer.disconnect();
            layer.observer = null;
          }
          if (layer.canvas.style.display !== 'none') {
            layer.canvas.style.display = 'none';
          }
          layer.stateKey = null;
        };

        const showCloudLayer = () => {
          const layer = cloudLayerMem.get(bg);
          if (!layer?.canvas) return;
          if (!layer.canvas.isConnected) {
            bg.appendChild(layer.canvas);
          }
          if (layer.canvas.style.display === 'none') {
            layer.canvas.style.display = '';
          }
        };

        const clear = ({ keepClouds = false } = {}) => {
          bg.querySelectorAll('.bc-wx-p-wrap,.bc-wx-flash').forEach(n => n.remove());
          if (keepClouds) {
            // Ensure cloud layer stays visible when keeping clouds
            showCloudLayer();
          } else {
            hideCloudLayer();
          }
        };

        if (!bgOn) {
          clear();
          bg._wxKey = null;
          return;
        }

        const setGrad = css => {
          bg.style.backgroundImage = css;
          bg.style.backgroundSize = 'cover';
          bg.style.backgroundPosition = 'center';
        };

        const addFlash = () => {
          if (!animOn) return;
          for (let i = 0; i < 2; i++) {
            const f = document.createElement('div');
            f.className = 'bc-wx-flash';
            f.style.animationDelay = (Math.random()*3 + 1) + 's';
            bg.appendChild(f);
          }
        };

        const makeWrap = () => {
          const wrap = document.createElement('div');
          wrap.className = 'bc-wx-p-wrap';
          wrap.innerHTML = '<div class="row front"></div><div class="row back"></div>';
          return { wrap, front: wrap.firstElementChild, back: wrap.lastElementChild };
        };

        const addParticles = ({ kind='rain', intensity='normal', style='' } = {}) => {
          if (!animOn) return;
          const maps = {
            rain: { light:16, normal:26, heavy:44 },
            snow: { light:72, normal:120, heavy:180 },
            hail: { light:14, normal:22, heavy:34 },
            stars:{ light:14, normal:32, heavy:46 }
          };

          let count = (maps[kind] || maps.stars)[intensity] || (maps[kind] || maps.stars).normal;

          // Adjust rain quantity based on precipitation if available
          if (kind === 'rain' && !Number.isNaN(precip) && precip > 0) {
             // Mapping: 0-10mm -> 10-100 particles (approx)
             count = Math.min(200, Math.max(10, Math.floor(precip * 8 + 10)));
          }

          const { wrap, front, back } = makeWrap();
          if (style) wrap.setAttribute('style', style);

          if (kind === 'stars') wrap.classList.add('bc-stars');

          if (kind === 'rain') {
            const build = (row, invert=false) => {
              const step = 100 / count;
              let html = '';
              for (let i = 0; i < count; i++) {
                const pos = (i*step) + Math.random()*step*0.6;
                const side = invert ? 'right' : 'left';
                const base = 1.1 + Math.random()*0.7;
                const delay = `-${(Math.random()*base).toFixed(2)}s`;
                const dur = `${base.toFixed(2)}s`;
                const bottom = `${100 + Math.floor(Math.random()*40)}%`;
                html +=
                  `<div class="bc-wx-p rain"
                    style="${side}:${pos}%;
                           bottom:${bottom};
                           --d:${dur};
                           --dl:${delay}"></div>`;
              }
              row.innerHTML = html;
            };
            build(front,false);
            build(back,true);
            bg.appendChild(wrap);
            return;
          }

          if (kind === 'snow') {
            const build = (row, scale=1, opacity=1) => {
              let html = '';
              for (let i = 0; i < count; i++) {
                const left = (Math.random()*100).toFixed(2);
                const top = -150 - Math.floor(Math.random()*200);
                const base = 14 + Math.random()*12;
                const dur = `${base.toFixed(2)}s`;
                const delay = `-${(Math.random()*base).toFixed(2)}s`;
                const drift = `${(Math.random()*36 - 18).toFixed(1)}px`;
                const size = Math.min(4, (Math.random()*2.5 + 1.5) * scale).toFixed(1);
                const op = Math.min(1, Math.max(0.9, opacity)).toFixed(2);
                html +=
                  `<div class="bc-wx-p snow"
                    style="left:${left}%;
                           top:${top}px;
                           animation-delay:${delay};
                           animation-duration:${dur};
                           --drift:${drift};
                           width:${size}px;
                           height:${size}px;
                           opacity:${op}"></div>`;
              }
              row.innerHTML = html;
            };
            build(front, 1, 1);
            build(back, 0.8, 0.75);
            bg.appendChild(wrap);
            return;
          }

          if (kind === 'hail') {
            const build = (row, scale=1) => {
              let html = '';
              for (let i = 0; i < count; i++) {
                const left = (Math.random()*100).toFixed(2);
                const top = -120 - Math.floor(Math.random()*160);
                const base = 2.4 + Math.random()*1.8;
                const dur = `${base.toFixed(2)}s`;
                const delay = `-${(Math.random()*base).toFixed(2)}s`;
                const drift = `${(Math.random()*8 - 4).toFixed(1)}px`;
                const size = Math.min(4, Math.max(2, (Math.random()*2 + 2) * scale)).toFixed(1);
                html +=
                  `<div class="bc-wx-p hail"
                    style="left:${left}%;
                           top:${top}px;
                           animation-delay:${delay};
                           animation-duration:${dur};
                           --drift:${drift};
                           width:${size}px;
                           height:${size}px;
                           opacity:1"></div>`;
              }
              row.innerHTML = html;
            };
            build(front, 1);
            build(back, 0.9);
            bg.appendChild(wrap);
            return;
          }

          if (kind === 'stars') {
            const build = (row, scale=1, opacity=1) => {
              let html = '';
              for (let i = 0; i < count; i++) {
                const left = (Math.random()*100).toFixed(2);
                const top = (Math.random()*50).toFixed(2);
                const base = 2 + Math.random()*3;
                const dur = `${base.toFixed(2)}s`;
                const delay = `-${(Math.random()*base).toFixed(2)}s`;
                const size = ((Math.random()*1.8 + 0.6) * scale).toFixed(2);
                const op = Math.min(1, Math.max(.35, opacity*Math.random())).toFixed(2);
                html +=
                  `<div class="bc-wx-p star"
                    style="left:${left}%;
                           top:${top}%;
                           width:${size}px;
                           height:${size}px;
                           opacity:${op};
                           --d:${dur};
                           --dl:${delay}"></div>`;
              }
              row.innerHTML = html;
            };
            build(front, 1, 1);
            build(back, 0.85, 0.7);
            bg.appendChild(wrap);
            return;
          }
        };

        const baseUrl = 'https://raw.githubusercontent.com/Clooos/Bubble-Card/refs/heads/main/img/';
        const cloudUrl = `${baseUrl}cloud.png`;
        const MAX_CLOUDS = 18;

        // Shared cloud image cache with pre-rendered night version
        const cloudImgCache = window.__bcWF.cloudImg || (window.__bcWF.cloudImg = {
          img: null,
          imgNight: null,
          loading: false,
          loaded: false
        });

        const createNightCloud = (img) => {
          // Pre-render night version using pixel manipulation for Safari compatibility
          const w = img.naturalWidth || img.width;
          const h = img.naturalHeight || img.height;
          const offscreen = document.createElement('canvas');
          offscreen.width = w;
          offscreen.height = h;
          const octx = offscreen.getContext('2d');
          if (!octx) return null;

          octx.drawImage(img, 0, 0);
          const imageData = octx.getImageData(0, 0, w, h);
          const data = imageData.data;

          // Apply brightness(0.4), contrast(1.25), hue-rotate(215deg)
          const hueShift = 215 * Math.PI / 180;
          const cosH = Math.cos(hueShift);
          const sinH = Math.sin(hueShift);

          for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];

            // Brightness (0.4)
            r *= 0.4;
            g *= 0.4;
            b *= 0.4;

            // Contrast (1.25)
            r = ((r / 255 - 0.5) * 1.25 + 0.5) * 255;
            g = ((g / 255 - 0.5) * 1.25 + 0.5) * 255;
            b = ((b / 255 - 0.5) * 1.25 + 0.5) * 255;

            // Hue rotation (215deg) using rotation matrix
            const rr = r, gg = g, bb = b;
            r = rr * (0.213 + cosH * 0.787 - sinH * 0.213)
              + gg * (0.715 - cosH * 0.715 - sinH * 0.715)
              + bb * (0.072 - cosH * 0.072 + sinH * 0.928);
            g = rr * (0.213 - cosH * 0.213 + sinH * 0.143)
              + gg * (0.715 + cosH * 0.285 + sinH * 0.140)
              + bb * (0.072 - cosH * 0.072 - sinH * 0.283);
            b = rr * (0.213 - cosH * 0.213 - sinH * 0.787)
              + gg * (0.715 - cosH * 0.715 + sinH * 0.715)
              + bb * (0.072 + cosH * 0.928 + sinH * 0.072);

            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
          }

          octx.putImageData(imageData, 0, 0);
          return offscreen;
        };

        const loadCloudImage = () => {
          if (cloudImgCache.loaded || cloudImgCache.loading) return;
          cloudImgCache.loading = true;
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            cloudImgCache.img = img;
            cloudImgCache.imgNight = createNightCloud(img);
            cloudImgCache.loaded = true;
            cloudImgCache.loading = false;
          };
          img.onerror = () => { cloudImgCache.loading = false; };
          img.src = cloudUrl;
        };

        const getCloudLayer = () => {
          if (!bg) return null;
          let record = cloudLayerMem.get(bg);
          if (record?.canvas && record.clouds?.length === MAX_CLOUDS) {
            return record;
          }

          loadCloudImage();

          const canvas = document.createElement('canvas');
          canvas.className = 'bc-wx-cloud-canvas';
          canvas.style.width = '100%';
          canvas.style.height = '100%';

          const clouds = [];
          for (let i = 0; i < MAX_CLOUDS; i++) {
            const width = Math.floor(Math.random() * 180) + 140;
            const height = Math.floor(width * 0.6);
            const topPercent = (Math.random() * 0.6) - 0.4;
            const opacity = Math.random() * 0.35 + 0.5;
            const speed = 0.012 + Math.random() * 0.028;
            const offset = (i / MAX_CLOUDS) + Math.random() * 0.08;
            clouds.push({ width, height, topPercent, opacity, speed, offset, x: 0 });
          }

          // Sort by opacity for depth effect (darker = further back)
          clouds.sort((a, b) => a.opacity - b.opacity);

          record = { canvas, clouds, stateKey: null, animId: null, ctx: null };
          cloudLayerMem.set(bg, record);
          return record;
        };

        const addClouds = ({ intensity = 'normal', isNight = false } = {}) => {
          if (!animOn || !bg) return;

          const layer = getCloudLayer();
          if (!layer) return;
          const { canvas, clouds } = layer;

          if (!canvas.isConnected) {
            bg.appendChild(canvas);
          }
          if (canvas.style.display === 'none') {
            canvas.style.display = '';
          }

          const countMap = { light: 6, normal: 8, heavy: 12 };
          const baseCount = countMap[intensity] || 10;
          const targetCount = Math.min(MAX_CLOUDS, baseCount);

          let direction = 1;
          if (!Number.isNaN(windBearing) && windBearing >= 0 && windBearing <= 180) {
            direction = -1;
          }

          const windFactor = Math.max(0, windSpeed);
          const speedMultiplier = 1 + (windFactor * 0.02);

          const stateKey = [intensity, isNight ? 1 : 0, direction].join('|');
          const needsRestart = layer.stateKey !== stateKey || !layer.animId;
          layer.stateKey = stateKey;

          if (layer.animId && !needsRestart) return;

          if (layer.animId) {
            cancelAnimationFrame(layer.animId);
            layer.animId = null;
          }

          const resizeCanvas = () => {
            const rect = bg.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const w = Math.floor(rect.width);
            const h = Math.floor(rect.height);
            if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
              canvas.width = w * dpr;
              canvas.height = h * dpr;
              canvas.style.width = w + 'px';
              canvas.style.height = h + 'px';
            }
            return { w, h, dpr };
          };

          let lastTime = 0;
          let isVisible = true;

          // Pause animation when tab is hidden
          const handleVisibility = () => {
            if (document.hidden) {
              isVisible = false;
            } else {
              isVisible = true;
              lastTime = 0;
              if (!layer.animId && canvas.isConnected && canvas.style.display !== 'none') {
                layer.animId = requestAnimationFrame(animate);
              }
            }
          };
          document.addEventListener('visibilitychange', handleVisibility, { passive: true });

          // Use IntersectionObserver to pause when off-screen
          if ('IntersectionObserver' in window && !layer.observer) {
            layer.observer = new IntersectionObserver((entries) => {
              isVisible = entries[0]?.isIntersecting ?? true;
              if (isVisible && !layer.animId && canvas.isConnected && canvas.style.display !== 'none') {
                lastTime = 0;
                layer.animId = requestAnimationFrame(animate);
              }
            }, { threshold: 0 });
            layer.observer.observe(canvas);
          }

          const animate = (timestamp) => {
            if (!canvas.isConnected || canvas.style.display === 'none') {
              layer.animId = null;
              return;
            }

            // Skip frame if not visible (tab hidden or off-screen)
            if (!isVisible || document.hidden) {
              layer.animId = null;
              return;
            }

            const delta = lastTime ? Math.min((timestamp - lastTime) / 16.67, 3) : 1;
            lastTime = timestamp;

            const { w, h, dpr } = resizeCanvas();
            if (w === 0 || h === 0) {
              layer.animId = requestAnimationFrame(animate);
              return;
            }

            const ctx = canvas.getContext('2d', { alpha: true });
            if (!ctx) {
              layer.animId = requestAnimationFrame(animate);
              return;
            }

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, w, h);

            // Use pre-rendered night image for Safari compatibility
            const img = isNight && cloudImgCache.imgNight
              ? cloudImgCache.imgNight
              : cloudImgCache.img;
            if (!img) {
              layer.animId = requestAnimationFrame(animate);
              return;
            }

            const dayOpacityMap = { light: 0.65, normal: 0.5, heavy: 0.4 };
            const dayOpacityFactor = dayOpacityMap[intensity] || 0.5;

            for (let i = 0; i < targetCount; i++) {
              const cloud = clouds[i];
              cloud.offset += cloud.speed * speedMultiplier * direction * delta * 0.01;

              if (direction > 0 && cloud.offset > 1.3) {
                cloud.offset = -0.3 - (cloud.width / w);
              } else if (direction < 0 && cloud.offset < -0.3 - (cloud.width / w)) {
                cloud.offset = 1.3;
              }

              const x = cloud.offset * w;
              const y = cloud.topPercent * h;
              const cw = cloud.width;
              const ch = cloud.height;

              ctx.globalAlpha = isNight ? cloud.opacity * 0.5 : cloud.opacity * dayOpacityFactor;
              ctx.drawImage(img, x, y, cw, ch);
            }

            ctx.globalAlpha = 1;

            layer.animId = requestAnimationFrame(animate);
          };

          layer.animId = requestAnimationFrame(animate);
        };

        const condRaw = String(ha?.states?.[entityId]?.state || '').toLowerCase();
        const condBase = condRaw.replace(/-night$/,'').replace(/-day$/,'');
        const cond = condBase;
        const nightForecast =
          Array.isArray(currentList) && currentList.length
            ? isNight(currentList[0])
            : isNight();
        const isNightMode = condRaw.endsWith('-night') || nightForecast;

        const keyForNight = c => {
          if (c === 'clear' || c === 'sunny') return 'clear-night';
          return c ? `${c}-night` : 'default-night';
        };

        const FX = {
          sunny: { bg: `
            linear-gradient(rgba(255,255,255,.06) 0%, rgba(255,255,255,0) 30%),
            radial-gradient(200% 150% at 50% 0%, rgb(255 238 230) 0%, rgba(255,245,204,0) 60%),
            linear-gradient(rgb(0 127 255) 0%, rgb(0 149 255) 50%, rgb(0 139 255) 100%)
          `},
          'clear-night': { bg: `
            radial-gradient(120% 100% at 50% 130%, hsla(260,80%,6%,.8) 0%, rgba(0,0,0,0) 60%),
            linear-gradient(180deg, hsl(235,47%,17%) 0%, hsl(252,39%,22%) 55%, hsl(260,35%,18%) 100%)
          `, precip:[{ kind:'stars', intensity:'normal' }]},

          partlycloudy: { bg: `
            radial-gradient(160% 120% at 85% -10%, hsla(48,95%,85%,.55) 0%, rgba(255,255,255,0) 55%),
            linear-gradient(180deg, hsl(214,25%,78%) 0%, hsl(209,22%,70%) 50%, hsl(207,48%,57%) 100%)
          `, clouds: { intensity: 'light', isNight: false }},
          'partlycloudy-night': { bg: `
            radial-gradient(160% 120% at 85% -10%, hsla(260,35%,20%,.6) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(235,32%,16%) 0%, hsl(242,28%,20%) 55%, hsl(250,26%,18%) 100%)
          `, precip:[{ kind:'stars', intensity:'light' }], clouds: { intensity: 'light', isNight: true }},

          cloudy: { bg: `
            linear-gradient(180deg, hsl(210,16%,65%) 0%, hsl(210,12%,58%) 50%, hsl(210,10%,52%) 100%)
          `, clouds: { intensity: 'heavy', isNight: false }},
          'cloudy-night': { bg: `
            linear-gradient(180deg, hsl(230,16%,24%) 0%, hsl(235,14%,22%) 55%, hsl(240,12%,20%) 100%)
          `, clouds: { intensity: 'heavy', isNight: true }},

          fog: { bg: `
            linear-gradient(180deg, hsl(210,20%,85%) 0%, hsl(210,20%,80%) 45%, hsl(210,20%,76%) 100%)
          `},
          windy: { bg: `
            linear-gradient(180deg, hsl(205,40%,78%) 0%, hsl(205,40%,72%) 50%, hsl(205,38%,66%) 100%)
          `},
          'windy-variant': { bg: `
            linear-gradient(180deg, hsl(205,40%,78%) 0%, hsl(205,40%,72%) 50%, hsl(205,38%,66%) 100%)
          `, clouds: { intensity: 'heavy', isNight: false }},
          hail: { bg: `
            linear-gradient(180deg, hsl(208,28%,62%) 0%, hsl(210,28%,56%) 55%, hsl(210,28%,52%) 100%)
          `, precip:[{ kind:'hail', intensity:'normal' }]},
          rainy: { bg: `
            linear-gradient(180deg, hsl(208,32%,52%) 0%, hsl(210,30%,58%) 60%, hsl(210,28%,66%) 100%)
          `, precip:[{ kind:'rain', intensity:'normal' }]},
          pouring: { bg: `
            linear-gradient(180deg, hsl(210,24%,32%) 0%, hsl(210,22%,40%) 55%, hsl(210,22%,48%) 100%)
          `, precip:[{ kind:'rain', intensity:'heavy' }]},
          lightning: { bg: `
            linear-gradient(180deg, hsl(220,18%,18%) 0%, hsl(220,16%,28%) 55%, hsl(220,16%,36%) 100%)
          `, flash:true},
          'lightning-rainy': { bg: `
            linear-gradient(180deg, hsl(220,18%,18%) 0%, hsl(220,16%,28%) 55%, hsl(220,16%,36%) 100%)
          `, precip:[{ kind:'rain', intensity:'normal' }], flash:true},
          snowy: { bg: `
            linear-gradient(180deg, hsl(208 46% 74%) 0%, hsl(210,42%,96%) 55%, hsl(210,46%,98%) 100%)
          `, precip:[{ kind:'snow', intensity:'normal' }]},
          'snowy-rainy': { bg: `
            linear-gradient(180deg, hsl(212 17% 53%) 0%, hsl(210,34%,92%) 55%, hsl(210,38%,96%) 100%)
          `, precip:[
            { kind:'snow', intensity:'light' },
            { kind:'rain', intensity:'normal',
              style:'--rain-r:20;--rain-g:20;--rain-b:20;--rain-a:.58;--rain-w:1.6px;--rain-h:90%' }
          ]},
          exceptional: { bg: `
            linear-gradient(180deg, hsl(12,64%,38%) 0%, hsl(12,58%,44%) 55%, hsl(12,54%,50%) 100%)
          `},
          default: { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(42,92%,84%,.55) 0%, rgba(255,255,255,0) 55%),
            linear-gradient(180deg, hsl(205,60%,78%) 0%, hsl(210,62%,70%) 55%, hsl(200,58%,64%) 100%)
          `},
          'default-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(260,60%,10%,.6) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(235,30%,16%) 0%, hsl(245,26%,18%) 55%, hsl(255,24%,16%) 100%)
          `},
          'rainy-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(220,44%,14%,.7) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(215,22%,22%) 0%, hsl(215,20%,26%) 55%, hsl(215,18%,30%) 100%)
          `, precip:[{ kind:'rain', intensity:'normal' }]},
          'pouring-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(220,44%,12%,.8) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(215,20%,16%) 0%, hsl(215,18%,22%) 55%, hsl(215,16%,28%) 100%)
          `, precip:[{ kind:'rain', intensity:'heavy' }]},
          'hail-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(210,36%,16%,.65) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(210,24%,22%) 0%, hsl(210,22%,28%) 55%, hsl(210,20%,32%) 100%)
          `, precip:[{ kind:'hail', intensity:'normal' }]},
          'snowy-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(220,28%,16%,.6) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(220,20%,22%) 0%, hsl(220,18%,30%) 55%, hsl(220,16%,34%) 100%)
          `, precip:[{ kind:'snow', intensity:'normal' }]},
          'snowy-rainy-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(215,28%,14%,.65) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(215,18%,22%) 0%, hsl(215,18%,28%) 55%, hsl(215,16%,32%) 100%)
          `, precip:[
            { kind:'snow', intensity:'light' },
            { kind:'rain', intensity:'normal',
              style:'--rain-r:200;--rain-g:200;--rain-b:200;--rain-a:.66;--rain-w:1.4px;--rain-h:82%' }
          ]},
          'lightning-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(230,32%,10%,.72) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(230,18%,16%) 0%, hsl(230,18%,22%) 55%, hsl(230,16%,28%) 100%)
          `, flash:true},
          'lightning-rainy-night': { bg: `
            radial-gradient(120% 80% at 50% 120%, hsla(230,32%,10%,.72) 0%, rgba(0,0,0,0) 55%),
            linear-gradient(180deg, hsl(230,18%,16%) 0%, hsl(230,18%,22%) 55%, hsl(230,16%,28%) 100%)
          `, precip:[{ kind:'rain', intensity:'normal' }], flash:true},
          'windy-variant-night': { bg: `
            linear-gradient(180deg, hsl(230,16%,24%) 0%, hsl(235,14%,22%) 55%, hsl(240,12%,20%) 100%)
          `, clouds: { intensity: 'heavy', isNight: true }}
        };

        const fxKey = isNightMode ? keyForNight(cond) : cond;
        const fx = FX[fxKey] || (isNightMode ? FX['default-night'] : FX.default);

        const stateKey = JSON.stringify({
          c: fxKey,
          p: fx.precip ? fx.precip.map(p => p.kind+':'+p.intensity).join('+') : '',
          f: !!fx.flash,
          cl: fx.clouds ? `${fx.clouds.intensity}:${fx.clouds.isNight}` : ''
        });
        const wantsClouds = !!fx.clouds;
        const hadClouds = bg._wxHadClouds;
        bg._wxHadClouds = wantsClouds;

        // If state hasn't changed, just ensure clouds are properly displayed
        if (bg._wxKey === stateKey) {
          if (wantsClouds) addClouds(fx.clouds);
          else if (hadClouds) hideCloudLayer();
          return;
        }

        // State changed - update everything
        // Only clear particles/flash, handle clouds separately to minimize DOM changes
        bg.querySelectorAll('.bc-wx-p-wrap,.bc-wx-flash').forEach(n => n.remove());

        setGrad(fx.bg);

        if (wantsClouds) {
          addClouds(fx.clouds);
        } else {
          hideCloudLayer();
        }

        if (fx.precip) fx.precip.forEach(addParticles);
        if (fx.flash) addFlash();
        bg._wxKey = stateKey;
      };

      if (skipFullRedraw) {
        applyWeatherOnly();
        updateWeatherPosition();
        applyBackground();
        return;
      }

      const render = items => {
        const containerWidth = container?.clientWidth || container?.offsetWidth || 0;
        const width = root.clientWidth || host.clientWidth || containerWidth || 0;
        // When width is 0, show all requested items without column limit
        const maxCols = width > 0 ? Math.max(1, Math.floor(width / minW)) : max;
        // Fit the forecast on a single row by limiting the visible items to the available columns.
        const visibleCount = Math.min(items.length, max, maxCols);
        const cols = Math.max(visibleCount, 1);
        const dataKey = items.map(f => [
          f.datetime || f.time || f.date || '',
          f.condition || '',
          f.temperature ?? f.temphigh ?? f.high ?? '',
          f.templow ?? f.low ?? f.apparent_temperature_min ?? ''
        ].join('|')).join(';');
        const renderKey = `${Math.round(width)}|${cols}|${dataKey}`;
        if (grid._wxRenderKey === renderKey) {
          updateWeatherPosition();
          applyWeatherOnly();
          return;
        }
        grid._wxRenderKey = renderKey;
        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        while (grid.children.length < visibleCount) {
          const wrap = el('div','bc-weather-day');
          const labelEl = el('div','day-label');
          const icon = el('ha-icon');
          const temps = el('div','temps');
          const hi = el('div','hi');
          const lo = el('div','lo');
          temps.append(hi, lo);
          wrap.append(labelEl, icon, temps);
          wrap._label = labelEl;
          wrap._icon = icon;
          wrap._hi = hi;
          wrap._lo = lo;
          grid.appendChild(wrap);
        }

        for (let i = 0; i < grid.children.length; i++) {
          const wrap = grid.children[i];
          const visible = i < visibleCount;
          wrap.style.display = visible ? 'grid' : 'none';
          if (!visible) continue;

          const f = items[i] || {};
          const dt = f.datetime || f.time || f.date || '';
          wrap._label.textContent = label(dt);
          wrap._icon.setAttribute(
            'icon',
            getWeatherIcon(String(f.condition||'').toLowerCase())
          );
          wrap._hi.textContent = fmt(f.temperature ?? f.temphigh ?? f.high);

          if (type === 'hourly') {
            wrap._lo.textContent = '';
            wrap._lo.style.display = 'none';
          } else {
            wrap._lo.style.display = '';
            wrap._lo.textContent =
              fmt(f.templow ?? f.low ?? f.apparent_temperature_min) || '';
          }
        }
        // Update position after render - use immediate mode for faster update
        updateWeatherPosition(true);
        applyWeatherOnly();
      };

      const observe = () => {
        if (!host || !root || !hostState) return;
        if (hostState.resizeObserver) return;
        if (root._ro) {
          try { root._ro.disconnect(); } catch {}
          root._ro = null;
        }
        const handleResize = () => {
          if (hostState.resizeFrame) {
            cancelAnimationFrame(hostState.resizeFrame);
          }
          hostState.resizeFrame = requestAnimationFrame(() => {
            hostState.resizeFrame = null;
            render(currentList || []);
          });
        };
        const ro = new ResizeObserver(handleResize);
        try { ro.observe(host); } catch {}
        try { ro.observe(root); } catch {}
        if (container && container !== host) {
          try { ro.observe(container); } catch {}
        }
        hostState.resizeObserver = ro;
        
        // Dedicated ResizeObserver for height updates in weather-only mode
        if (!root._heightRo && isWeatherOnlyMode) {
          const heightUpdateFrame = () => {
            if (hostState.heightUpdateFrame) {
              cancelAnimationFrame(hostState.heightUpdateFrame);
            }
            hostState.heightUpdateFrame = requestAnimationFrame(() => {
              hostState.heightUpdateFrame = null;
              updateWeatherPosition(true);
            });
          };
          root._heightRo = new ResizeObserver(heightUpdateFrame);
          try { root._heightRo.observe(root); } catch {}
        }
        
        watchHostParent();
        scheduleDetachPoll();
      };

      const ttlMs = ttlMin*60*1000;
      const cacheKey = `bcwf|${entityId}|${type}|max:${max}`;
      const requestKey = `${entityId}|${type}`;

      const toTimestamp = f => {
        const dt = f?.datetime || f?.time || f?.date;
        const ts = dt ? new Date(dt).getTime() : NaN;
        return Number.isNaN(ts) ? null : ts;
      };

      const normalizeForecast = raw => {
        if (!Array.isArray(raw)) return [];

        const sorted = [...raw].sort((a, b) => {
          const ta = toTimestamp(a);
          const tb = toTimestamp(b);
          if (ta == null && tb == null) return 0;
          if (ta == null) return 1;
          if (tb == null) return -1;
          return ta - tb;
        });

        const cutoff = now - 30*60*1000;
        const trimmed =
          type === 'hourly'
            ? sorted.filter(f => {
                const ts = toTimestamp(f);
                if (ts == null) return true;
                return ts >= cutoff;
              })
            : sorted;

        const usable = trimmed.length ? trimmed : sorted;
        return usable.slice(0, max);
      };

      const getCache = () => {
        const m = cacheMem[cacheKey];
        if (m && now - m.ts <= ttlMs) return m.data;
        try {
          const r = JSON.parse(localStorage.getItem(cacheKey) || 'null');
          if (r && now - r.ts <= ttlMs) return r.data;
        } catch {}
        return null;
      };

      const setCache = d => {
        cacheMem[cacheKey] = { ts: now, data: d };
        pruneMemStore(cacheMem, 8);
        try {
          localStorage.setItem(cacheKey, JSON.stringify({ ts: now, data: d }));
        } catch {}
      };

      const extractForecast = (r) => {
        if (!r) return [];
        if (Array.isArray(r?.[entityId]?.forecast)) return r[entityId].forecast;
        if (Array.isArray(r?.response?.[entityId]?.forecast)) return r.response[entityId].forecast;
        if (Array.isArray(r?.forecast)) return r.forecast;
        if (Array.isArray(r?.result?.forecast)) return r.result.forecast;
        if (Array.isArray(r?.response?.forecast)) return r.response.forecast;
        if (Array.isArray(r?.results)) {
          const hit = r.results.find(x => [x?.entity_id, x?.entityId, x?.target]?.includes(entityId)) || r.results[0];
          return extractForecast(hit);
        }
        if (Array.isArray(r)) {
          const first = r.find(x => x?.entity_id === entityId) || r[0];
          return extractForecast(first);
        }
        return [];
      };

      const cached = normalizeForecast(getCache());
      if (Array.isArray(cached) && cached.length) {
        currentList = cached;
        render(cached);
        observe();
        applyBackground();
        applyWeatherOnly();
        return;
      }

      const fetchForecast = () => {
        const existing = requestMem[requestKey];
        if (existing?.promise && (Date.now() - existing.ts) < 10000) {
          return existing.promise;
        }
        const promise = ha.callWS({
          type:'call_service',
          domain:'weather',
          service:'get_forecasts',
          service_data:{ entity_id: entityId, type },
          return_response:true
        }).finally(() => {
          if (requestMem[requestKey]?.promise === promise) {
            delete requestMem[requestKey];
          }
        });
        requestMem[requestKey] = { promise, ts: Date.now() };
        return promise;
      };

      fetchForecast()
      .then(res => {
        const list = normalizeForecast(extractForecast(res));
        if (list.length) {
          currentList = list;
          setCache(list);
          render(list);
          observe();
        }
      })
      .catch(e => console.warn('Weather Forecast: WS error', e))
      .finally(() => {
        applyBackground();
        applyWeatherOnly();
        if (!currentList) { render([]); observe(); }
      });
    })()}
  editor:
    - type: expandable
      title: Forecast
      icon: mdi:calendar-clock
      schema:
        - name: type
          label: Forecast type
          selector:
            select:
              options:
                - label: Daily
                  value: daily
                - label: Hourly
                  value: hourly
                - label: Twice daily
                  value: twice_daily
        - name: max_days
          label: Max items
          selector:
            number:
              min: 1
              max: 10
    - type: expandable
      title: Layout and styling
      icon: mdi:palette
      schema:
        - name: disable_animations
          label: Disable animations
          selector:
            boolean: {}
        - name: disable_dynamic_background
          label: Disable weather based background
          selector:
            boolean: {}
        - name: hide_icon_background
          label: Hide icon background
          selector:
            boolean: {}
        - name: min_day_width
          label: Min column width in px
          selector:
            number:
              min: 50
              max: 160
        - name: card_layout
          label: Card layout
          selector:
            select:
              options:
                - label: Default
                  value: default
                - label: Square card
                  value: square
                - label: Weather only
                  value: weather_only_bg
                - label: Weather only (hide header and background)
                  value: weather_only
                - label: Background only (hide weather)
                  value: background_only
                - label: Background only (hide weather and header)
                  value: background_only_minimal
